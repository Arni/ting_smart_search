<?php

/**
 * @file
 * Ting smart search module main file.
 */

/**
 * Implements hook_ctools_plugin_directory().
 *
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types.
 */
function ting_smart_search_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function ting_smart_search_ctools_plugin_api($module, $api) {
  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
  if ($module == "strongarm" && $api == "strongarm") {
    return array("version" => "1");
  }
}

/**
 * Implements hook_cron().
 */
function ting_smart_search_cron() {
  //TODO cleanup messy code
  $last_run = variable_get('ting_smart_search_last_cron', 0);
  $interval = variable_get('ting_smart_search_interval', 36000);
  if (time() - $last_run > $interval) {
    // If possible we get a already processed file from a master server else we
    // import directly from webtrekk
    $master_server = variable_get('ting_smart_search_master_server', null);
    $webtrekk_server = variable_get('ting_smart_search_webtrekk_server', null);
    if (isset($master_server)) {
      ting_smart_search_get_autodata_from_master($master_server);
      watchdog('Smart Search', 'imported from master server: %time', array('%time' => time()), 'WATCHDOG_INFO');
    } elseif (isset($webtrekk_server)) {
      ting_smart_search_get_autodata_from_webtrekk($webtrekk_server);
      watchdog('Smart Search', 'imported from webtrekk server: %time', array('%time' => time()), 'WATCHDOG_INFO');
    }
    variable_set('ting_smart_search_last_cron', time());
  }


  //watchdog('Smart Search','last import: %last_run', array('%last_run' =>$last_run),'WATCHDOG_INFO');
  //watchdog('ting_smart_search','last import: %last_run', array('%last_run' =>$last_run));
}

/**
 *  For use in the submit function of form
 *  cache_clear_all(':'.current_path(), 'cache_ting', TRUE);
 *   drupal_set_message('Cache for '.'*'.current_path().' this record cleared.');
 *
 */
function ting_smart_search_opensearch_cache_key(&$cid) {
  // Determine context.
  $context = 'search';

  // Modify cache key based on some context.
  if ($context === 'search') {
    $cid = ':' . current_path() . ':' . $cid;
  }
}

/**
 * Set additional parameters to ting request.
 *
 * @param object $request
 *   The Ting request.
 *
 * @return array
 *   Array containing key=>value pairs. Key is the name of the parameter.
 */
function ting_smart_search_opensearch_pre_execute($request) {

// Alter the request based on the profile settings and request class.
  switch (get_class($request)) {
    //case 'TingClientObjectRequest':
    //case 'TingClientCollectionRequest':
    case 'TingClientSearchRequest':
      // Always use the search well profile on search requests if set.
      // Otherwise this profile wants to use the default from ting module.
      // In case you need to add additional parameters to request.

      $smart_search_check_sort = '';
      $smart_search_check_boosts = array();
      $smart_search_check_object_boosts = false;

      // store the userDefinedBoost if any
      $smart_search_userdefined_boosts = $request->userDefinedBoost;
      if (substr($request->getQuery(), 0, 1) === "(") {
        //$smart_search_check_replaced = ting_smart_search_check_replaced($request->getQuery());
        // $smart_search_check_replaced() - now obsolete
        // Load the entity as object with entity_metadata_wrapper
        $smart_search_object = ting_smart_search_check_object($request->getQuery());
        if (!empty((array) $smart_search_object)) {
          $status = $smart_search_object->field_status->value();
          if ($status == 'planned') {
            $date_array = $smart_search_object->field_sss_date->value();
            $date_start = $date_array['value'];
            $date_end = $date_array['value2'];
            $date_delta = $date_end - $date_start;
            $now = time();
            if ($date_delta > 0 && $date_start < $now && $now < $date_end) {
              $status = 'active';
            }
            if ($date_delta == 0 && $date_start < time()) {
              $status = 'active';
            }
          }
          if ($status == 'active') {
            $smart_search_check_replaced = '';
            $redirect = $smart_search_object->field_alternate_search_string->value();
            // Add a general quoted free text search.
            if (!empty($free_text_query = $redirect)) {
              $cqlDoctor = new TingSearchCqlDoctor($free_text_query);
              $smart_search_check_replaced = $cqlDoctor->string_to_cql();
            }

            // Check for sorting
            $smart_search_request_sort = $request->getSort();
            $params = $_POST;
            $param_sort = NULL; //drupal_get_query_parameters();

            if ($smart_search_request_sort == 'rank_frequency') {

              if (array_key_exists('sort', $params)) {
                // Do nothing here
              } else {
                // Override sort when no sort has been specified
                //ting_smart_search_check_sort() - now obsolete
                $smart_search_check_sort = $smart_search_object->field_sss_sort->value();

                if (!empty($smart_search_check_sort)) {
                  $request->setSort($smart_search_check_sort);
                }
              }

              $smart_search_check_boosts = ting_smart_search_check_boosts($smart_search_object);
            }

            if ($smart_search_check_replaced == '') {
              $query = $request->getQuery();
              //Probably nothing here
            } else {
              $query = $smart_search_check_replaced;
            }

            if ($smart_search_check_boosts) {
              $uboosts = $smart_search_userdefined_boosts;
              foreach ($smart_search_check_boosts as $boost_field) {
                $uboosts[] = array(
                    'fieldName' => $boost_field['field_name'],
                    'fieldValue' => $boost_field['field_value'],
                    'weight' => $boost_field['weight'],
                );
              }
              $request->userDefinedBoost = $uboosts;
            }
            $request->queryDebug = 'true';
            $request->setQuery($query);
          }
        }
      }
      if (!$smart_search_check_object_boosts && variable_get('ting_smart_search_use_auto', true)) {
        $request->userDefinedBoost = ting_smart_search_auto($smart_search_userdefined_boosts, $request->fullTextQuery); //Todo add support for fulltextquery in opensearch module
      }

      break;
  }

  return NULL;
}

function ting_smart_search_auto($smart_search_userdefined_boosts, $keys) {
  $data = ting_smart_search_autodata_cache();

  if (isset($data) && array_key_exists($keys, $data)) {
    $i = 0;
    $weight = 10000;
    foreach ($data[$keys] as $faust => $objects) {
      $smart_search_userdefined_boosts[] = array(
          'fieldName' => 'term.default',
          'fieldValue' => urldecode($faust),
          'weight' => $weight,
      );
      $weight = $weight - 1000;
      $i += 1;
      if ($i > 4) {
        break;
      }
    }
  }
  return $smart_search_userdefined_boosts;
}

function ting_smart_search_autodata_cache() {
  @include ting_smart_search_get_autodata_path();
  return isset($ting_smart_search_autodata) ? $ting_smart_search_autodata : false;
}

/**
 * Check if query has been replaced
 *
 * @param string $query
 *   The Ting query.
 *
 * @return string
 *   The replaced string or empty
 */
function ting_smart_search_check_object($query) {
  $redirect = '';
  $new_string_object = new stdClass();

  $string = trim($query, '()');
  $string = str_replace(' and ', ' ', $string);

  $ssquery = new EntityFieldQuery();

  $ssquery->entityCondition('entity_type', 'ting_type')
          ->entityCondition('bundle', 'smart_search_string')
          ->propertyCondition('title', $string, '=');

  $result = $ssquery->execute();

  if (isset($result['ting_type'])) {
    $string_items_nids = array_keys($result['ting_type']);
    $new_string_object = entity_metadata_wrapper('ting_type', $string_items_nids[0]);
  }

  return $new_string_object;
}

/**
 * Check if query has boosts
 *
 * @param string $query
 *   The Ting query.
 *
 * @return array
 *   The boost array or empty
 */
function ting_smart_search_check_boosts($wrapper) {
  $boosts = array();
  $boost_materials = array();
  $weight = 20000;
  $entity_id = 1;

  if ($entity_id) {
    $boost_materials = $wrapper->field_sss_boost_materials->value();

    // We insert material twice to rule out factors applied from the well
    if (!empty($boost_materials)) {
      foreach ($boost_materials as $boost_material) {
        $boosts[] = array(
                    'field_name' => 'term.default',
                    'field_value' => urldecode($boost_material),
                    'weight' => $weight,
        );
        $weight = $weight - 100;
        $boosts[] = array(
                    'field_name' => 'term.default',
                    'field_value' => urldecode($boost_material),
                    'weight' => $weight,
        );
        $weight = $weight - 2000;
      }
    }

    //extract custom boosts from search string
    $custom_boost_materials = $wrapper->field_custom_boost_values->value();

    //get to each fieldcollection
    foreach ($custom_boost_materials as $cb_material) {
      $cb_wrapper = entity_metadata_wrapper('field_collection_item', $cb_material);
      $boosts[] = array(
                  'field_name' => $cb_wrapper->field_field_name->value(),
                  'field_value' => $cb_wrapper->field_field_boost_value->value(),
                  'weight' => $cb_wrapper->field_field_boost_weight->value(),
      );
    }
  }
  return $boosts;
}

/**
 * Implements hook_menu().
 */
function ting_smart_search_menu() {
  $items = array();

  $items['admin/config/ding/ting_smart_search'] = array(
      'title' => 'Ting smart search',
      'description' => 'Manage smart search module',
      'page callback' => 'ting_smart_search_admin_page',
      'page arguments' => array(),
      'access arguments' => array('configure smart search'),
      'file' => 'includes/ting_smart_search.admin.inc',
  );

  $items['admin/config/ding/ting_smart_search_soaptest'] = array(
      'title' => 'Ting smart soap test',
      'description' => 'Test smart search soap connection',
      'page callback' => 'ting_smart_search_soap_page',
      'page arguments' => array(),
      'access arguments' => array('configure smart search'),
      'file' => 'includes/ting_smart_search_soap.inc',
  );

  $items['smartstring/%'] = array(
      'title' => 'Smart search string',
      'page callback' => 'ting_smart_search_view_sss',
      'page arguments' => array(1),
      'access arguments' => array('configure smart search'),
  );

  //Testing

  $items['autoparse'] = array(
      'title' => 'auto',
      'page callback' => 'ting_smart_search_get_searchdata_from_webtrekk',
      'page arguments' => array(),
      'access arguments' => array(),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function ting_smart_search_permission() {
  return array(
      'configure smart search' => array(
          'title' => t('Configure smart search'),
          'description' => t('Allow role to configure smart search.'),
      ),
  );
}

/**
 * Load a single record.
 *
 * @param $id
 *    The id representing the record we want to load.
 */
function ting_smart_search_load($id, $reset = FALSE) {
  return ting_smart_search_load_multiple(array($id), array(), $reset);
}

/**
 * Load multiple records.
 */
function ting_smart_search_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('smart_search_string', $ids, $conditions, $reset);
}

function ting_smart_search_form_alter(&$form, &$form_state, $form_id) {

  // Check when the right form is passed
  if ($form_id == 'eck__entity__form_edit_ting_type_smart_search_string' || $form_id == 'eck__entity__form_add_ting_type_smart_search_string') {

    // hide url redirect on this entity
    $form['redirect']['#access'] = FALSE;
    $form['field_sss_hits_per_month']['und']['0']['value']['#attributes']['disabled'] = TRUE;
    $form['field_sss_hits_per_year']['und']['0']['value']['#attributes']['disabled'] = TRUE;
    $form['field_sss_hits_score']['und']['0']['value']['#attributes']['disabled'] = TRUE;

    // Make the form element collapsed when smart search string not found
    if ($form['form_id']['#value'] == 'eck__entity__form_edit_ting_type_smart_search_string') {
      $form['#groups']['group_elements']->format_settings['formatter'] = 'collapsible';
    } else {
      $form['title']['#default_value'] = check_plain(arg(2));
    }
    $form['title']['#title'] = t('Søgestreng');
    $form['title']['#disabled'] = TRUE;
    $form['title']['#size'] = 100;
    $form['field_alternate_search_string']['#size'] = 100;

    // Make the date field dynamic based on the value of the status fields
    $form['field_sss_date']['#states'] = array(
        // Only show this field when the value of status is planned.
        'visible' => array(
            ':input[name="field_status[und]"]' => array('value' => 'planned'),
        ),
    );

    if (empty($form['field_sss_sort']['und']['#default_value'])) {
      $form['#groups']['group_sss_sort_group']->format_settings['formatter'] = 'collapsed';
      if (!empty($form['field_alternate_search_string']['und'][0]['value']['#default_value']) ||
              !empty($form['field_content_reference']['und'][0]['target_id']['#default_value'])) {

        $form['#groups']['group_sss_search_and_ref']->format_settings['formatter'] = 'collapsible';
      } else {
        $form['#groups']['group_sss_search_and_ref']->format_settings['formatter'] = 'collapsed';
      }
      if (!empty($form['field_sss_boost_materials']['und'][0]['value']['#default_value']) ||
              !empty($form['field_custom_boost_values']['und'][0]['field_field_boost_value']['und'][0]['value']['#default_value'])) {

        $form['#groups']['group_sss_boost']->format_settings['formatter'] = 'collapsible';
      } else {
        $form['#groups']['group_sss_boost']->format_settings['formatter'] = 'collapsed';
      }
    } else {
      $form['#groups']['group_sss_search_and_ref']->format_settings['formatter'] = 'collapsed';
      $form['#groups']['group_sss_boost']->format_settings['formatter'] = 'collapsed';
      $form['#groups']['group_sss_sort_group']->format_settings['formatter'] = 'collapsible';
    }

    $form['actions']['submit_to_list'] = array(
        '#value' => t('Gå til oversigt'),
        '#type' => 'submit',
        '#submit' => array('smart_search_string_to_list'),
    );

    // form callback functions
    $form['#pre_render'][] = 'smart_search_string_form_pre_render';
    $form['#after_build'][] = 'smart_search_string_form_after_build';
    $form['#submit'][] = 'smart_search_string_form_submit';
  }

  if ($form_id == 'ting_search_sort_form') {
    $form['#submit'][] = 'ting_smart_search_sort_form_submit';
  }
}

/**
 * Pre render callback to smartstring add/edit form
 * use   $form['#pre_render'][] = 'smart_search_string_form_pre_render'; in form
 * Add magic to the form.
 */
function smart_search_string_form_pre_render($form) {
  //move title and submit inside fieldset
  $form['group_elements']['title'] = $form['title'];
  unset($form['title']);
  $form['group_elements']['actions'] = $form['actions'];
  unset($form['actions']);

  return $form;
}

/**
 * After build callback to smartstring add/edit form
 * use   $form['#after_build'][] ='smart_search_string_form_after_build'; in form
 * Add CSS to the form.
 */
function smart_search_string_form_after_build($form, &$form_state) {
  $path = drupal_get_path('module', 'ting_smart_search');
  drupal_add_css($path . '/css/smart_search_string_form.css');

  return $form;
}

function smart_search_string_form_submit($form, &$form_state) {
  // Return for to current search path
  $form_state['redirect'] = current_path();

  cache_clear_all(':' . current_path(), 'cache_opensearch', TRUE);
  drupal_set_message('Cache for ' . '*' . current_path() . ' this record cleared.');
}

function smart_search_string_to_list($form, &$form_state) {
  // Return to list of search strings
  drupal_goto('/admin/structure/entity-type/ting_type/smart_search_string/list');
}

function ting_smart_search_sort_form_submit($form, &$form_state) {
  
}

function smart_search_string_views_pre_render(&$view) {

  if ($view->name == 'smart_search_content') {

    foreach ($view->result as $r => $result) {
      
    }
  }

  // other views might go here
}

/**
 * Add extra view mode to smart search content
 */
function smart_search_string_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['col2'] = array(
      'label' => t('Two columns'),
      'custom settings' => TRUE,
  );
  $entity_info['node']['view modes']['link-only'] = array(
      'label' => t('Link only'),
      'custom settings' => TRUE,
  );
}

/**
 * Add custom values from smart search settings to field_field_name in field collection field_custom_boost_values
 */
function smart_search_string_field_info_alter(&$field_info) {
  
}

function ting_smart_search_preprocess_node(&$variables) {
  // Append class based on view mode
  if (isset($variables['field_view_mode']) && !empty($variables['field_view_mode'])) {
    $variables['classes_array'][] = $variables['field_view_mode']['und'][0]['value'];
  }
}

function ting_smart_search_parse_autodata() {
  print 'starting';
  $data = array();
  $lines = array();
  $path = file_default_scheme() . '://' . variable_get('ting_smart_search_autodata_path', 'smartsearchdata') . DIRECTORY_SEPARATOR . 'rawdata.csv';

  try {
    $file = fopen($path, 'r');

    while (($line = fgetcsv($file, 1000, "\t")) !== FALSE) {
      $lines[] = $line;
    }
    fclose($file);

    foreach ($lines as $line) {

      $search = explode('.search.ting.', $line[0]);
      $search_string = $search[1];
      $hits = $line[2];
      $object = null;
      if (strpos($line[1], '.ting.object.') !== false) {
        $object = explode('.ting.object.', $line[1]);
      } else if (strpos($line[1], '.ting.collection.') !== false) {
        $object = explode('.ting.collection.', $line[1]);
      }
      $faust = $object[1];
      if (isset($object)) {
        if (!array_key_exists($search_string, $data)) {
          $data[$search_string] = array();
        }

        if (!array_key_exists($faust, $data[$search_string])) {
          $data[$search_string][$faust] = $hits;
        } else {
          $data[$search_string][$faust] += $hits;
        }
      }
    }

    $output = array();
    foreach ($data as $search => $objects) {
      arsort($objects);
      $output[$search] = array_slice($objects, 0, 5);
    }

    $val = var_export($output, true);
    file_put_contents(ting_smart_search_get_autodata_path(), '<?php $ting_smart_search_autodata = ' . $val . ';'); //, LOCK_EX doesn't work maybe a windows issue
  } catch (Exception $e) {
    watchdog('ting_smart_search', 'Failed to parse rawdata file ' . $e->getMessage());
  }
  print 'finished';
}

function ting_smart_search_get_autodata_path() {
  return file_default_scheme() . '://' . variable_get('ting_smart_search_autodata_path', 'smartsearchdata') . DIRECTORY_SEPARATOR . 'autodata.txt';
}

/**
 * Gets a file with data automatic smart search from master server
 */
function ting_smart_search_get_autodata_from_master($url) {
  //$url = variable_get('ting_smart_search_master_server', 'https://staging.randersbib.dk/sites/default/files/shareddata/autodata.txt');
  $path = ting_smart_search_get_autodata_path();

  $directory = dirname($path);

  try {
    $ch = curl_init($url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    $data = curl_exec($ch);
    curl_close($ch);

    // Build the destination folder tree if it doesn't already exist.
    if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
      watchdog('ting_smart_search', 'Failed to create directory: %directory', array('%directory' => $directory), WATCHDOG_ERROR);
      return FALSE;
    }

    file_put_contents($path, $data);
  } catch (Exception $e) {
    watchdog('ting_smart_search', 'Fetching auto smart search data failed: ' . $e->getMessage());
  }
}

/**
 * Gets a file with data automatic smart search from webtrekk
 */
function ting_smart_search_get_autodata_from_webtrekk($url) {
  
}


/**
 * Gets a file with data automatic smart search from webtrekk
 */
function ting_smart_search_get_searchdata_from_webtrekk() {
  file_put_contents("/var/www/drupal7vm/drupal/debug/feed2.txt", print_r("Ramt", TRUE), FILE_APPEND);
  print "starting";
  $search_data = array();
  $path = file_default_scheme() . '://' . variable_get('ting_smart_search_autodata_path', 'smartsearchdata') . DIRECTORY_SEPARATOR . 'searchfeed.csv';
  $url = variable_get('ting_smart_search_webtrekk_server_feed', 'http://www.kpiindex.com/index2/search_feed.csv');
  ting_smart_search_get_search_feed_file($url, $path);  
  //Todo get a better file format
  $file = fopen($path, 'r');
  while (($line = fgetcsv($file, 1000, ",")) !== FALSE) {
    $search_key = $line[2];
    $number_of_searches = $line[3];
    if (ting_smart_search_is_from_last_month($line, 13)) { 
      //Using a whole year creates memory problems so we only use the last 3 months
      if (array_key_exists($search_key, $search_data) && is_numeric($number_of_searches)) {
        $search_data[$search_key]['long_period'] += $number_of_searches;
      } else {
        $search_data[$search_key] = array('long_period' => $number_of_searches, 'short_period' => 0);
      }
      if (ting_smart_search_is_from_last_month($line, 4)) {
        $search_data[$search_key]['short_period'] += $number_of_searches;
      }
    }
  }

  uasort($search_data, 'ting_smart_search_sort_search_data');
  $search_data = array_slice($search_data, 0, variable_get('ting_smart_search_search_feed_updates', 1000)); 
  
//  foreach ($search_data as $key => $value) {
//     $output[] = $key . ',' . $value['three_months'] . ',' . $value['month'];
//  }
//  
  //  http://www.kpiindex.com/index2/search_feed.csv 
  
  file_put_contents("/var/www/drupal7vm/drupal/debug/feed1.txt", print_r($search_data, TRUE), FILE_APPEND);
}

/**
 * Gets a file with data automatic smart search from master server
 */
function ting_smart_search_get_search_feed_file($url, $path) {
  $directory = dirname($path);

  try {
//    $ch = curl_init($url);
//    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
//    $data = curl_exec($ch);
//    curl_close($ch);
//file_put_contents("/var/www/drupal7vm/drupal/debug/feed3.txt", print_r("Got file", TRUE), FILE_APPEND);
//    // Build the destination folder tree if it doesn't already exist.
//    if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
//      watchdog('ting_smart_search', 'Failed to create directory: %directory', array('%directory' => $directory), WATCHDOG_ERROR);
//      return FALSE;
//    }
//
//    file_put_contents($path, $data);
    ting_smart_search_copyfile_chunked($url, $path);
    file_put_contents("/var/www/drupal7vm/drupal/debug/feed3.txt", print_r("Got file", TRUE), FILE_APPEND);
  } catch (Exception $e) {
    watchdog('ting_smart_search', 'Fetching smart search data feed failed: ' . $e->getMessage());
  }
}

function ting_smart_search_is_from_last_month($line, $lookback_period = 4) {
  $date = new DateTime();
  $year = $date->format("Y");
  $week = $date->format("W");
  $search_year = $line[0];
  $search_week = $line[1];
  if ($search_year == $year && $week - $lookback_period <= $search_week) {
    return true;
  } else if (($search_year == $year - 1) && $week <= $lookback_period) {
    if ($search_week >= (52 - $lookback_period + $week)) {
      return true;
    }
  }
  return false;
}

function ting_smart_search_sort_search_data($a, $b) {
    if ($a['long_period'] == $b['long_period']) {
        return 0;
    }
    return ($a['long_period'] < $b['long_period']) ? 1 : -1;
}

/**
 * Copy remote file over HTTP one small chunk at a time.
 *
 * @param string $infile
 *   The full URL to the remote file
 * @param string $outfile
 *   The path where to save the file
 *
 * @return $cnt
 */
function ting_smart_search_copyfile_chunked($infile, $outfile) {
  $chunksize = 10 * (1024 * 1024); // 10 Megs

  /**
   * parse_url breaks a part a URL into it's parts, i.e. host, path,
   * query string, etc.
   */
  $parts = parse_url($infile);
  $i_handle = fsockopen($parts['host'], 80, $errstr, $errcode, 5);
  $o_handle = fopen($outfile, 'wb');

  if ($i_handle == FALSE || $o_handle == FALSE) {
    return FALSE;
  }

  if (!empty($parts['query'])) {
    $parts['path'] .= '?' . $parts['query'];
  }

  /**
   * Send the request to the server for the file
   */
  $request = "GET {$parts['path']} HTTP/1.1\r\n";
  $request .= "Host: {$parts['host']}\r\n";
  $request .= "User-Agent: Mozilla/5.0\r\n";
  $request .= "Keep-Alive: 115\r\n";
  $request .= "Connection: keep-alive\r\n\r\n";
  fwrite($i_handle, $request);

  /**
   * Now read the headers from the remote server. We'll need
   * to get the content length.
   */
  $headers = [];
  while (!feof($i_handle)) {
    $line = fgets($i_handle);
    if ($line == "\r\n") {
      break;
    }
    $headers[] = $line;
  }

  /**
   * Look for the Content-Length header, and get the size
   * of the remote file.
   */
  $length = 0;
  foreach ($headers as $header) {
    if (stripos($header, 'Content-Length:') === 0) {
      $length = (int) str_replace('Content-Length: ', '', $header);
      break;
    }
  }

  /**
   * Start reading in the remote file, and writing it to the
   * local file one chunk at a time.
   */
  $cnt = 0;
  while (!feof($i_handle)) {
    $buf = '';
    $buf = fread($i_handle, $chunksize);
    $bytes = fwrite($o_handle, $buf);
    if ($bytes == FALSE) {
      return FALSE;
    }
    $cnt += $bytes;

    /**
     * We're done reading when we've reached the content length
     */
    if ($cnt >= $length) {
      break;
    }
  }

  fclose($i_handle);
  fclose($o_handle);
  return $cnt;
}
